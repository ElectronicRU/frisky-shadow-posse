<!-- vim: set formatoptions=a shiftwidth=2: -->

# Дизайн-документ для FSP

## Используемые технологии
* Erlang/OTP <http://erlang.com>
* Nitrogen web framework <http://nitrogenproject.com>
* JQuery <http://jquery.com>

## Архитектура

### Возможности технологий

Nitrogen позволяет обмениваться данными Erlang <-> Web Browser в следующих
форматах:

* передача события DOM на сторону сервера (postback);

* передача вызова из JavaScript на сторону сервера, возможно, с дополнительными данными в
  формате Erlang (#api{} element);

* изменение DOM со стороны сервера (wf:update etc.)

* передача и выполнение произвольного JavaScript-кода (wf:wire).

### Процессное взаимодействие

Схема взаимодействия клиентского приложения с игровой логикой выглядит так:
(JavaScript в браузере) <-(websockets/AJAX)-> (процесс wf:comet) <-> (процесс
GameRoom)

JavaScript отвечает за трансляцию событий DOM в высокоуровневые события
приложения (разыгрывание карты из руки, выбор цели, перемещение существа, атака
существа).

Процесс wf:comet подсоединяется к серверу игровой комнаты и транслирует события
клиента в формат, понятный серверу, а также передаёт данные об игре от сервера
на сторону клиента. Таким образом, этот процесс выполняет функцию прослойки.

Процесс GameRoom (`src/fsp_gameroom.erl`) взаимодействует со всеми
подсоединёнными клиентами и занимается всей игровой логикой. Клиентам
отправляется оповещение о каждом низкоуровневом событии, произосшедшем в игре
(например, перемещение существа; полный список низкоуровневых событий см.
ниже), запросы, связанные с выбором цели (при разыгрывании карты или активации
способности существа, требующей цели), и глобальные события игры (например,
начало игры, смена очереди хода, конец игры, ...).

### Сервер

Сервер реализован в качестве машины состояний (поведение `gen_fsm`). Ниже
приведено приблизительное описание состояний сервера.

#### Начальное состояние (`wait_players`)

В этом состоянии сервер начинает работу. Корректными для него являются два
события: `player_join` и `player_leave`. Оба события являются синхронными;
возможные ответы -- успех или ошибка (в случае переполненного лобби или попытки
подключения одного и того же игрока с нескольких процессов).

PID процессов, посылающих события, на этом этапе заносятся в таблицу, и в
дальнейшем используются для асинхронной отправки событий клиентам.

Как только сервер набирает достаточно игроков, он рассылает им сообщения о
необходимости подтверждения готовности и переходит в состояние
`wait_player_accept`.

#### Ожидание подтверждения (`wait_player_accept`)

В этом состоянии сервер принимает сообщения `player_accept`, `player_unaccept`
(установка и отмена флага готовности), а также `player_leave`. При получении
сообщения `player_leave` сервер сбрасывает все флаги готовности и переходит в
начальное состояние, извещая об этом игроков.

После того, как все игроки подтвердили свою боевую готовность, им даётся
несколько секунд, чтобы передумать. По истечении этого времени сервер переходит
в состояние `game_turn`.

#### Игровой ход (`game_turn`)

Данное состояние характеризуется понятием *текущего игрока*. От текущего игрока
принимаются события `play_from_hand`, `creature_move`, `creature_attack`,
`trigger_activate`. Смысл всех событий, кроме последнего, прозрачен; смысл
последнего же состоит в том, что любая карта может иметь способность,
активируемую "по желанию игрока" в его главную фазу хода. Эти события являются
синхронными, по причинам, указанным ниже, и сервер немедленно возвращает
клиенту подтверждение о том, что его действие принято на рассмотрение.

После принятия одного из событий от текущего игрока, сервер производит
необходимые приготовления, связанные с действием, и переходит в состояние
`game_resolve`.

Кроме того, текущий игрок может закончить свой ход, при помощи соответствующей
функции в клиенте или просто достаточно долго подождав. Синхронное событие
`end_turn` в случае успеха запускает триггеры, связанные с концом хода, и
переходит в состояние `game_resolve`, которое ответственно за то, чтобы при
помощи базовых событий сменить текущего игрока, продвинуть счётчик ходов, и
тому подобное.

#### Выполнение действий в игре (`game_resolve`)

Как правило, разыгрывание карты, попытка передвижения или атаки, или активация
способности приводит к изменению состояния игры. Находясь в состоянии
`game_resolve`, сервер разрешает эффекты, указанные в тексте карт, до тех пор,
пока все действующие эффекты не завершатся. В этом состоянии сервер отвечает на
действия текущего игрока сигналом "попробуйте позже"; действительно попробовать
позже -- забота клиента.

(Надо заметить, что, как правило, разрешение действий в игре происходит гораздо
быстрее, чем это выглядит с точки зрения клиента; в частности, сервер может
перейти в состояние `game_turn`, пока клиенты всё ещё анимируют изменения.
Таким образом, на скорость действий игрока это обычно влияет незначительно.)

В этом состоянии сервер самостоятельно генерирует и отправляет себе сообщения
типа `action` или `trigger`. `action` означает низкоуровневое событие, которое
непосредственно меняет состояние игры, и о котором клиентам приходит
оповещение. `trigger` означает срабатывание активируемой способности (или
эффекта разгрывания карты из руки), которое, возможно, требует цели.

В этом состоянии сервер:

* обрабатывает все накопленные `action`, изменяя состояние игры и отправляя
оповещения клиентам.

* собирает мертвецов. Мертвецами считаются карты существ, находящиеся на доске,
чей уровень повреждений больше либо равен их уровню здоровья, а также карты,
которые были явно уничтожены игровым эффектом. Все триггеры, принадлежащие
мертвецам, игнорируются, кроме специального триггера `in_death`, который, при
наличии, немедленно добавляется в **текущий** список триггеров (то есть будет
обработан на этом ходу).

* Побочным эффектом сбора мертвецов или специального базового события может
являться проигрыш или выигрыш одного из игроков (когда один или несколько
игроков выигрывают игру, все остальные игроки её немедленно проигрывают). На
этом шаге сервер проверяет, не случилось ли подобного, и если случилось, то
рассылает победителям поздравления и переходит в состояние `game_end`.

* создаёт новые списки для накопления `action` и `trigger`.

* обрабатывает все ранее накопленные триггеры, не требующие цели; на этом этапе
состояние игры не меняется и сообщений клиентам не отправляется. При этом
генерируются новые сообщения `action` и `trigger`, которые заносятся в новые
списки.

* отправляет каждому из клиентов сообщение о том, какие цели ему надлежит
выбрать, и запускает процесс-обработчик для каждого триггера, требующего цели.
Процессы-обработчики берут дальнейшее общение с клиентами на себя.

* переходит в состояние `game_wait_target`.

Если списки `action` и `trigger` пусты, то вместо вышеописанного сервер
непосредственно переходит в состояние `game_turn`.

#### Ожидание выбора целей от клиентов (`game_wait_target`).

В этом состоянии сервер ожидает того или иного результата выбора целей от
клиентов. От процессов, запущенных в `game_resolve`, принимаются следующие
события:

* `target_success`: выбор цели завершился успешно, и соответствующий цели
триггер готов к работе.

* `target_cancel`: клиент отменил выбор цели или не успел выбрать цель. Это
сообщение отправляется только для триггеров, помеченных как "необязательные" (в
том числе, например, выбор цели для заклинания или места для существа при
разыгрывании карты из руки). Соответствующий цели триггер не будет запущен.

* `target_timeout`: триггер был помечен как "обязательный", однако клиент не
успел выбрать цель. Нормальное продолжение игры невозможно. Соответствующий
клиент насильственно отсоединяется, все предстоящие события, связанные с ним,
игнорируются, а соответствующий игрок объявляется проигравшим игру.

После того, как от всех клиентов получен ответ, сервер запускает все триггеры,
требующие цели, которые не были отменены, и переходит в состояние
`game_resolve`.


#### Конец игры (`game_end`)

В этом состоянии сервер завершает работу.

#### Обработка ошибочных сообщений

Может случиться так, что сервер получает событие, недопустимое для текущего
состояния. Если событие асинхронное, то оно игнорируется с занесением в журнал
ошибок. Если событие синхронное, то оно игнорируется с занесением в журнал
ошибок, а отправителю возвращается кортеж `{error,wrong_event_for_this_state}`.

#### Универсальные сообщения

На некоторые события сервер даёт одинаковый ответ вне зависимости от текущего
состояния (они должны быть отправлены при помощи
`(sync_)send_all_state_event`). Эти события:

* `game_stats`: отправляет в ответ ассоциативный массив со статистикой текущей
игры.

* `server_state`: отправляет в ответ текущее состояние сервера, а также краткое
содержание его полного внутреннего состояния.

* `game_state`: отправляет в ответ описание полного состояния игры (состояние
игроков и состояние игрового поля).

* `keep_alive`: отправляет в ответ атом `keep_alive`.

ни одно из описанных событий не меняет ни состояния конечной машины, ни
внутреннего состояния сервера.

